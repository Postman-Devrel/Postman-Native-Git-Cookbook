import { HttpError } from '../error';
import { HttpMetadata, HttpMethod, HttpResponse } from '../types';
import { LineDecoder } from '../utils/line-decoder';
import { Request } from './request';

/**
 * Interface for HTTP client adapters.
 * Defines the contract for sending HTTP requests and streaming responses.
 */
interface HttpAdapter {
  send(): Promise<HttpResponse>;
  stream(): AsyncGenerator<HttpResponse>;
}

/**
 * Fetch API-based HTTP adapter for executing requests.
 * Uses the native Fetch API to provide a consistent interface for both regular and streaming requests.
 * Handles headers, cookies, timeouts with AbortSignal, and error responses.
 *
 * @template T - The expected response type
 */
export class RequestFetchAdapter<T> implements HttpAdapter {
  private requestInit: RequestInit = {};

  constructor(private request: Request) {
    this.setMethod(request.method);
    this.setHeaders(request.getHeaders());
    this.setCookies(request.getCookies());
    this.setBody(request.body);
    this.setTimeout(request.config.timeoutMs);
  }

  /**
   * Executes the HTTP request and returns the response.
   * Fetches the full response body as an ArrayBuffer.
   *
   * @returns A promise resolving to the HTTP response with metadata and body
   */
  public async send(): Promise<HttpResponse<T>> {
    const response = await fetch(this.request.constructFullUrl(), this.requestInit);

    const metadata: HttpMetadata = {
      status: response.status,
      statusText: response.statusText || '',
      headers: this.getHeaders(response),
    };

    return {
      metadata,
      raw: response,
    };
  }

  /**
   * Executes the HTTP request as a stream, yielding chunks as they arrive.
   * Uses the Fetch API's ReadableStream and LineDecoder to split into lines.
   *
   * @returns An async generator yielding HTTP response chunks
   * @throws Error if responseHeaders is enabled (streaming not supported with responseHeaders)
   */
  public async *stream(): AsyncGenerator<HttpResponse<T>> {
    throw new Error(
      'Streaming is not supported when responseHeaders is enabled. ' +
        'Disable responseHeaders in SDK generation config to use streaming.',
    );
  }

  private setMethod(method: HttpMethod): void {
    if (!method) {
      return;
    }
    this.requestInit = {
      ...this.requestInit,
      method,
    };
  }

  private setBody(body: ReadableStream<Uint8Array> | null): void {
    if (!body) {
      return;
    }
    this.requestInit = {
      ...this.requestInit,
      body,
    };
  }

  private setHeaders(headers: HeadersInit | undefined): void {
    if (!headers) {
      return;
    }

    this.requestInit = {
      ...this.requestInit,
      headers,
    };
  }

  private setCookies(cookies: Record<string, string> | undefined): void {
    if (!cookies || Object.keys(cookies).length === 0) {
      return;
    }

    // Serialize cookies as a Cookie header
    const cookieString = Object.entries(cookies)
      .map(([key, value]) => `${key}=${value}`)
      .join('; ');

    this.requestInit = {
      ...this.requestInit,
      headers: {
        ...this.requestInit.headers,
        Cookie: cookieString,
      },
    };
  }

  private setTimeout(timeoutMs: number | undefined): void {
    if (!timeoutMs) {
      return;
    }

    this.requestInit = {
      ...this.requestInit,
      signal: AbortSignal.timeout(timeoutMs),
    };
  }

  private getHeaders(response: Response): Record<string, string> {
    const headers: Record<string, string> = {};
    response.headers.forEach((value: string, key: string) => {
      headers[key] = value;
    });

    return headers;
  }

  private toArrayBuffer(uint8Array: Uint8Array): ArrayBuffer {
    return uint8Array.buffer.slice(
      uint8Array.byteOffset,
      uint8Array.byteOffset + uint8Array.byteLength,
    );
  }
}
